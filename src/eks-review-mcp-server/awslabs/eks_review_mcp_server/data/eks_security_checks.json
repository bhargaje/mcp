{
    "iam_checks":{
        "I1":{
            "name": "Leverage EKS Cluster Access Manager to configure RBAC",
            "description": "Cluster Access Manager, now the preferred way to manage access of AWS IAM principals to Amazon EKS clusters",
            "category": "IAM",
            "severity": "Medium",
            "recommendation": "Use AWS CLI to enable the API or API_AND_CONFIG_MAP authentication mode using ```update-cluster-config``` command \n ```aws eks update-cluster-config --name <CLUSTER_NAME> --access-config authenticationMode=API ``` or use ```API_AND_CONFIG_MAP```"
        },
        "I2":{
            "name": "Make the EKS Cluster Endpoint private",
            "description": "By default when you provision an EKS cluster, the API cluster endpoint is set to public, i.e. it can be accessed from the Internet",
            "category": "IAM",
            "severity": "High",
            "recommendation": "Configure the EKS cluster endpoint to be private. Use AWS CLI command ```aws eks update-cluster-config --name <Cluster Name> --resources-vpc-config endpointPublicAccess=false,endpointPrivateAccess=true ```"
        },
        "I3":{
            "name": "Don't use a service account token for authentication",
            "description": "A service account token is a long-lived, static credential. If it is compromised, lost, or stolen, an attacker may be able to perform all the actions associated with that token until the service account is deleted.",
            "category": "IAM",
            "severity": "High",
            "recommendation": "you may need to grant an exception for applications that have to consume the Kubernetes API from outside the cluster, e.g. a CI/CD pipeline application. If such applications run on AWS infrastructure, like EC2 instances, consider using an instance profile and mapping that to a Kubernetes RBAC role."
        },
        "I4": {
            "name": "Employ least privileged access when creating RoleBindings and ClusterRoleBindings",
            "description": "When creating RoleBindings and ClusterRoleBindings, ensure that the Role or ClusterRole has the least privileged set of permissions.",
            "category": "IAM",
            "severity": "Medium",
            "recommendation": "Avoid using ['*'] in your Roles and ClusterRoles unless it's absolutely necessary. If you're unsure what permissions to assign, consider using a tool like audit2rbac to automatically generate Roles and binding based on the observed API calls in the Kubernetes Audit Log."
        },
        "I5": {
            "name": "Leverage EKS Pod Identity",
            "description": "EKS Pod Identity allows you to assign an IAM role to a kubernetes service account, without the need to configure an Open Id Connect (OIDC) identity provider(IDP) for each cluster in your AWS account",
            "category": "IAM",
            "severity": "Medium",
            "recommendation": "To use EKS Pod Identity, you must deploy an agent which runs as a DaemonSet pod on every eligible worker node. This agent is made available to you as an EKS Add-on and is a pre-requisite to use EKS Pod Identity feature. Your applications must use a supported version of the AWS SDK to use this feature"
        },
        "I6": {
            "name": "Ensure IMDSv2 is enforced in the worker node security configuration",
            "description": "IMDSv2 is the recommended Instance Metadata Service Version. IMDSv1 is deprecated and IMDSv2 is the recommended version.",
            "category": "IAM",
            "severity": "High",
            "recommendation": "Use the modify-instance-metadata-defaults command and specify the Region in which to modify the IMDS account level settings. Include --http-tokens set to required and --http-put-response-hop-limit set to 2 if your instances will host containers. Otherwise, specify -1 to indicate no preference. When -1 (no preference) is specified, at launch, the value defaults to 2 if the AMI has the setting ImdsSupport: v2.0; otherwise it defaults to 1. \n ```aws ec2 modify-instance-metadata-defaults --region us-east-1 --http-tokens required --http-put-response-hop-limit 2```"
        },
        "I7": {
            "name": "Run the application as a non-root user",
            "description": "Containers run as root by default. While this allows them to read the web identity token file, running a container as root is not considered a best practice",
            "category": "IAM",
            "severity": "High",
            "recommendation": "Consider adding the spec.securityContext.runAsUser attribute to the PodSpec."
        },
        "I8": {
            "name": "Check if IRSA is configured",
            "description": "IRSA is a feature that allows you to assign an IAM role to a Kubernetes service account. It works by leveraging a Kubernetes feature known as Service Account Token Volume Projection",
            "category": "IAM",
            "severity": "High",
            "recommendation": "if EKS Pod Identity is not enabled then make sure OIDC is enabled and IRSA is configured, Pods configured with a Service Account must references an IAM Role for accessing other AWS Services with a proper annotation For example ```eks.amazonaws.com/role-arn: arn:aws:iam::111122223333:role/my-role```"
        }
    },
    "pod_security": {
        "P1": {
            "name": "Check if Pod Security Standards (PSS) and Pod Security Admission (PSA) is configured",
            "description": "The PSA includes an admission controller webhook that implements the controls defined in the PSS.",
            "category": "Pod Security",
            "severity": "High",
            "recommendation": "Implement the controls defined by the PSS, PSA operates in three modes: \n 1.enforce: Policy violations will cause the pod to be rejected. \n 2.audit: Policy violations will trigger the addition of an audit annotation to the event recorded in the audit log, but are otherwise allowed. \n 3.warn: Policy violations will trigger a user-facing warning, but are otherwise allowed."
        },
        "P2": {
            "name": "Restrict the use of hostPath or if hostPath is necessary restrict which prefixes can be used and configure the volume as read-only",
            "description": "hostPath is a volume that mounts a directory from the host directly to the container",
            "category": "Pod Security",
            "severity": "High",
            "recommendation": "Avoide using HostPath if required configure the spec.containers.volumeMounts as readOnly"
        },
        "P3": {
            "name": "Check if the application is using the latest version of the image",
            "description": "The image tag should be immutable to avoid unexpected upgrades",
            "category": "Pod Security",
            "severity": "Medium",
            "recommendation": "Use immutable image tags to avoid unexpected upgrades"
        },
        "P4": {
            "name": "Do not allow privileged escalation",
            "description": "Privileged escalation allows a process to change the security context under which its running.",
            "category": "Pod Security",
            "severity": "High",
            "recommendation": "You can prevent a container from using privileged escalation by implementing a policy-as-code mutating policy that sets allowPrivilegeEscalation to false or by setting securityContext.allowPrivilegeEscalation in the podSpec"
        },
        "P5": {
            "name": "Configure your images with read-only root file system",
            "description": "Configuring your images with a read-only root file system prevents an attacker from overwriting a binary on the file system that your application uses",
            "category": "Pod Security",
            "severity": "Medium",
            "recommendation": "If your application has to write to the file system, consider writing to a temporary directory or attach and mount a volume. You can enforce this by setting the podâ€™s SecurityContext as ``` readOnlyRootFilesystem: true ```"
        },
        "P6": {
            "name": "Disable ServiceAccount token mounts",
            "description": "For pods that do not need to access the Kubernetes API, you can disable the automatic mounting of a ServiceAccount token",
            "category": "Pod Security",
            "severity": "Low",
            "recommendation": "Use the Pod Spec or Service Account Spec to disable the auto mount ``` automountServiceAccountToken: false ```"
        }
    
        
    },
    "multi_tenancy":{
        "M1": {
            "name": "Check if Network Policies are used restric communication between namespaces",
            "description": "By default, all pods in a Kubernetes cluster are allowed to communicate with each other. This behavior can be altered using network policies.",
            "category": "Multi-Tenancy",
            "severity": "Medium",
            "recommendation": "if you need a network isolation between namespaces, Amazon VPC CNI now supports Kubernetes Network Policies to create policies that can isolate sensitive workloads and protect them from unauthorized access when running Kubernetes on AWS"
        },
        "M2": {
            "name": "Check if Quotas are defined at the namespace level",
            "description": "Quotas are used to define limits on workloads hosted in your cluster. With quotas, you can specify the maximum amount of CPU and memory that a pod can consume, or you can limit the number of resources that can be allocated in a cluster or namespace.",
            "category": "Multi-Tenancy",
            "severity": "Low",
            "recommendation": "quotas can be configured on the namespaces in a multi-tenant environment to force tenants to specify requests and limits when scheduling their pods on the cluster."
        },
        "M3": {
            "name": "Isolating tenant workloads to specific nodes",
            "description": "Restricting tenant workloads to run on specific nodes can be used to increase isolation in the soft multi-tenancy model. With this approach, tenant-specific workloads are only run on nodes provisioned for the respective tenants",
            "category": "Multi-Tenancy",
            "severity": "Medium",
            "recommendation": "To achieve this isolation, native Kubernetes properties (node affinity, and taints and tolerations) are used to target specific nodes for pod scheduling, and prevent pods, from other tenants, from being scheduled on the tenant-specific nodes."
        }
        
    },
    "detective_controls": {
        "D1": {
            "name": "Check if the EKS Control Plane logs are enabled",
            "description": "Collecting and analyzing logs is useful for a variety of different reasons. Logs can help with root cause analysis and attribution",
            "category": "Detective Controls",
            "severity": "High",
            "recommendation": "AWS Service Access Policies allow you to grant access to AWS services to your IAM role, without granting access to your AWS account. If you have not configured any AWS Service Access Policies, you can ignore this recommendation."
        }
    },
    "network_security": {

    },
    "data_encryption_and_secrets_mgmt": {
        "DE1": {
            "name": "Check if Encryption is enbled in the StorgeClass",
            "description": "Encrypting data at rest is considered a best practice. If youâ€™re unsure whether encryption is necessary, encrypt your data.",
            "category": "Data Encryption and Secrets Mgmt",
            "severity": "High",
            "recommendation": "There are three different AWS-native storage options you can use with Kubernetes: EBS, EFS, and FSx for Lustre. All three offer encryption at rest using a service managed key or a customer master key (CMK)"
        },
        "DE2":{
            "name": "Use an external secrets provider",
            "description": "External Secrets provider offer features such as fine grained access controls, strong encryption, and automatic rotation of secrets that are not available with Kubernetes Secrets",
            "category": "Data Encryption and Secrets Mgmt",
            "severity": "High",
            "recommendation": "There are three different AWS-native storage options you can use with Kubernetes: EBS, EFS, and FSx for Lustre. All three offer encryption at rest using a service managed key or a customer master key (CMK)"
        }
          
    },
    "runtime_security": {
    },
    "infra_security": {
        "IS1": {
            "name": "Check if the workers nodes are deployed onto private subnets",
            "description": "By deploying workers onto private subnets, you minimize their exposure to the Internet where attacks often originate.",
            "category": "Infra Security",
            "severity": "High",
            "recommendation": "Ensure you are using Private subnets for worker nodes"
        },
        "IS2": {
            "name": "Use an OS optimized for running containers",
            "description": "Using a Container optimized ensures the performance and also reduces the attack surface",
            "category": "Infra Security",
            "severity": "High",
            "recommendation": "Consider using Flatcar Linux, Project Atomic, RancherOS, and Bottlerocket, Alternately, use the EKS optimized AMI for your Kubernetes worker nodes"
        },
        "IS3": {
            "name": "Minimize access to worker nodes",
            "description": "Instead of enabling SSH access for the worker nodes, use SSM Session Manager when you need to remote into a host.",
            "category": "Infra Security",
            "severity": "Medium",
            "recommendation": "Use Session Manager to access the worker node EC2 console "
        }
    }

}