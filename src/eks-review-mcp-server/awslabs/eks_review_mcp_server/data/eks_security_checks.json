{
    "iam_checks":{
        "I1":{
            "name": "Leverage EKS Cluster Access Manager to configure RBAC",
            "description": "Cluster Access Manager, now the preferred way to manage access of AWS IAM principals to Amazon EKS clusters",
            "category": "IAM",
            "severity": "Medium",
            "recommendation": "Use AWS CLI to enable the API or API_AND_CONFIG_MAP authentication mode using ```update-cluster-config``` command \n ```aws eks update-cluster-config --name <CLUSTER_NAME> --access-config authenticationMode=API ``` or use ```API_AND_CONFIG_MAP```"
        },
        "I2":{
            "name": "Make the EKS Cluster Endpoint private",
            "description": "By default when you provision an EKS cluster, the API cluster endpoint is set to public, i.e. it can be accessed from the Internet",
            "category": "IAM",
            "severity": "High",
            "recommendation": "Configure the EKS cluster endpoint to be private. Use AWS CLI command ```aws eks update-cluster-config --name <Cluster Name> --resources-vpc-config endpointPublicAccess=false,endpointPrivateAccess=true ```"
        },
        "I3":{
            "name": "Don't use a service account token for authentication",
            "description": "A service account token is a long-lived, static credential. If it is compromised, lost, or stolen, an attacker may be able to perform all the actions associated with that token until the service account is deleted.",
            "category": "IAM",
            "severity": "High",
            "recommendation": "you may need to grant an exception for applications that have to consume the Kubernetes API from outside the cluster, e.g. a CI/CD pipeline application. If such applications run on AWS infrastructure, like EC2 instances, consider using an instance profile and mapping that to a Kubernetes RBAC role."
        },
        "I4": {
            "name": "Employ least privileged access when creating RoleBindings and ClusterRoleBindings",
            "description": "When creating RoleBindings and ClusterRoleBindings, ensure that the Role or ClusterRole has the least privileged set of permissions.",
            "category": "IAM",
            "severity": "Medium",
            "recommendation": "Avoid using ['*'] in your Roles and ClusterRoles unless it's absolutely necessary. If you're unsure what permissions to assign, consider using a tool like audit2rbac to automatically generate Roles and binding based on the observed API calls in the Kubernetes Audit Log."
        },
        "I5": {
            "name": "Leverage EKS Pod Identity",
            "description": "EKS Pod Identity allows you to assign an IAM role to a kubernetes service account, without the need to configure an Open Id Connect (OIDC) identity provider(IDP) for each cluster in your AWS account",
            "category": "IAM",
            "severity": "Medium",
            "recommendation": "To use EKS Pod Identity, you must deploy an agent which runs as a DaemonSet pod on every eligible worker node. This agent is made available to you as an EKS Add-on and is a pre-requisite to use EKS Pod Identity feature. Your applications must use a supported version of the AWS SDK to use this feature"
        },
        "I6": {
            "name": "Ensure IMDSv2 is enforced in the worker node security configuration",
            "description": "IMDSv2 is the recommended Instance Metadata Service Version. IMDSv1 is deprecated and IMDSv2 is the recommended version.",
            "category": "IAM",
            "severity": "High",
            "recommendation": "Use the modify-instance-metadata-defaults command and specify the Region in which to modify the IMDS account level settings. Include --http-tokens set to required and --http-put-response-hop-limit set to 2 if your instances will host containers. Otherwise, specify -1 to indicate no preference. When -1 (no preference) is specified, at launch, the value defaults to 2 if the AMI has the setting ImdsSupport: v2.0; otherwise it defaults to 1. \n ```aws ec2 modify-instance-metadata-defaults --region us-east-1 --http-tokens required --http-put-response-hop-limit 2```"
        },
        "I7": {
            "name": "Run the application as a non-root user",
            "description": "Containers run as root by default. While this allows them to read the web identity token file, running a container as root is not considered a best practice",
            "category": "IAM",
            "severity": "High",
            "recommendation": "Consider adding the spec.securityContext.runAsUser attribute to the PodSpec."
        },
        "I8": {
            "name": "Check if IRSA is configured",
            "description": "IRSA is a feature that allows you to assign an IAM role to a Kubernetes service account. It works by leveraging a Kubernetes feature known as Service Account Token Volume Projection",
            "category": "IAM",
            "severity": "High",
            "recommendation": "if EKS Pod Identity is not enabled then make sure OIDC is enabled and IRSA is configured, Pods configured with a Service Account must references an IAM Role for accessing other AWS Services with a proper annotation For example ```eks.amazonaws.com/role-arn: arn:aws:iam::111122223333:role/my-role```"
        }
    },
    "pod_security": {
        "P1": {
            "name": "Check if Pod Security Standards (PSS) and Pod Security Admission (PSA) is configured",
            "description": "The PSA includes an admission controller webhook that implements the controls defined in the PSS.",
            "category": "Pod Security",
            "severity": "High",
            "recommendation": "Implement the controls defined by the PSS, PSA operates in three modes: \n 1.enforce: Policy violations will cause the pod to be rejected. \n 2.audit: Policy violations will trigger the addition of an audit annotation to the event recorded in the audit log, but are otherwise allowed. \n 3.warn: Policy violations will trigger a user-facing warning, but are otherwise allowed."
        },
        "P2": {
            "name": "Restrict the use of hostPath or if hostPath is necessary restrict which prefixes can be used and configure the volume as read-only",
            "description": "hostPath is a volume that mounts a directory from the host directly to the container",
            "category": "Pod Security",
            "severity": "High",
            "recommendation": "Avoide using HostPath if required configure the spec.containers.volumeMounts as readOnly"
        },
        "P3": {
            "name": "Check if the application is using the latest version of the image",
            "description": "The image tag should be immutable to avoid unexpected upgrades",
            "category": "Pod Security",
            "severity": "Medium",
            "recommendation": "Use immutable image tags to avoid unexpected upgrades"
        },
        "P4": {
            "name": "Do not allow privileged escalation",
            "description": "Privileged escalation allows a process to change the security context under which its running.",
            "category": "Pod Security",
            "severity": "High",
            "recommendation": "You can prevent a container from using privileged escalation by implementing a policy-as-code mutating policy that sets allowPrivilegeEscalation to false or by setting securityContext.allowPrivilegeEscalation in the podSpec"
        },
        "P5": {
            "name": "Configure your images with read-only root file system",
            "description": "Configuring your images with a read-only root file system prevents an attacker from overwriting a binary on the file system that your application uses",
            "category": "Pod Security",
            "severity": "Medium",
            "recommendation": "If your application has to write to the file system, consider writing to a temporary directory or attach and mount a volume. You can enforce this by setting the podâ€™s SecurityContext as ``` readOnlyRootFilesystem: true ```"
        },
        "P6": {
            "name": "Disable ServiceAccount token mounts",
            "description": "For pods that do not need to access the Kubernetes API, you can disable the automatic mounting of a ServiceAccount token",
            "category": "Pod Security",
            "severity": "Low",
            "recommendation": "Use the Pod Spec or Service Account Spec to disable the auto mount ``` automountServiceAccountToken: false ```"
        }
    
        
    }
}